from primitives import Primitives
from rules import Rules
from tools import Tools

import numpy as np
import sys
import random
import time



def main(write):
    """
    Currently the different primitives and names are tracked in lists an arrays. Kemp and Regier 
    do it by using 3D arrays, I did that to. 

    The way it is generating contains a lot of double looping but generates the relational matrixes in
    the exact same order als Kemp and Regier which made comparing them easier. Now that it works the 
    can be made more efficiently again. It is on the list. 
    """

    def append_category(name, matrix, score):
        """
        Should do more in the future when these components are stored separatly.
        Written inside the function so that the variable category can be accessed easily.
        """
        if sum(sum(matrix)) == 0:
            return
        categories.append((name, matrix, score))
        return 

    primitives = Primitives()
    rules = Rules()
    ts = Tools()

    # Load the initial primitives
    singles = [(name, ts.filter_familymembers(matrix), score) for name, matrix, score in primitives.singles]
    doubles =  [(name, ts.filter_familymembers(matrix), score) for name, matrix, score in primitives.doubles]

#   Concepts contains the categories generated by previous rounds while categories contains all the newly generated categories
#   as well. This is to prevent that categories generated in for example round two aren't immediately used for generating. 
    categories = doubles.copy()
    concepts = categories.copy()

    close_max = 12
    depth = 3
    ego = False

    for depth in range(depth): 
        start_time = time.clock()
        print("\nStarting depth {} with {} categories".format(depth+1, len(concepts)))

        for name_d, matrix_d, score_d in concepts:
            # One binary (self refering rules)
            name_inv = [name_d, name_d, "inv"]
            name_symm_clos = [name_d, name_d, "sy_clos"]
            name_tran_clos = [name_d, name_d, "tr_clos"]
            score = 1 + score_d
            append_category(name_inv, rules.inverse(matrix_d), score)
            append_category(name_symm_clos, rules.symmetric_closure(matrix_d), score)
            append_category(name_tran_clos, rules.transitive_closure(matrix_d, close_max), score)

        for name_s, matrix_s, score_s in singles:
            # Binary - Unary (A(x,y) -- B(x) case)
            for name_d, matrix_d, score_d in concepts:
                score = 1 + score_d + score_s
                name_conj_x = [name_s, name_d, "conjx"]
                name_conj_y = [name_d, name_s, "conjy"]
                matrix_conj_x, matrix_conj_y = rules.conjunction(matrix_d, matrix_s, "singles")
                append_category(name_conj_x, matrix_conj_x, score)
                append_category(name_conj_y, matrix_conj_y, score)


                # Disjunctive rules
                name_disj_x = [name_d, name_s, "disjx"]
                name_disj_y = [name_d, name_s, "disjy"]
                matrix_disj_x, matrix_disj_y = rules.disjunction(matrix_d, matrix_s, "singles")
                append_category(name_conj_x, matrix_disj_x, score)
                append_category(name_conj_y, matrix_disj_y, score)
                

        i = 0
        for name_d, matrix_d, score_d in concepts:
            # Two Binary rules (A(x,y) --- B(x,y))
            j = 0
            for name_d2, matrix_d2, score_d2 in concepts:
                score = 1 + score_d + score_d2
                if j > i:
                    # Conjuctive rule.
                    name_conj = [name_d, name_d2, "conj"]
                    append_category(name_conj, rules.conjunction(matrix_d, matrix_d2), score)

                    # Disjuctive rule.
                    name_disj = [name_d, name_d2, "disj"]
                    append_category(name_disj, rules.disjunction(matrix_d, matrix_d2), score)

                # Transtive rule.
                name_tran = [name_d, name_d2, "tran"]
                append_category(name_tran, rules.transitive(matrix_d, matrix_d2), score)
                j +=1
            i +=1

        # Filter by ego at depth 3 (or depth == 2)
        if depth == 2:
            ego = True

        print("Total categories:", len(categories))

        categories = ts.filter_by_score(categories, ego)
        end_time = time.clock()
        concepts = categories.copy()

        print("Executing depth {} took {}.".format(depth+1, end_time-start_time))
        print("Remaining categories:", len(categories))

        if write == "True":
            ts.write_matrix_to_file(categories, path_matrix="concepts/bn_matrix_depth_" + str(depth+1), path_names="concepts/bn_names_depth_" + str(depth+1))


if __name__ == "__main__":
    args = sys.argv
    if len(args) == 1 or len(args) > 2:
        print("Write True if matrixes need to be saved to file!")
        sys.exit()
    else:
        main(args[1])
